# ğŸ“‹ è¯„ä¼°è¯¦æƒ…éŸ³é¢‘è·å–å®Œæ•´æŒ‡å—

## ğŸ“– æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜å¦‚ä½•ä»è¯„ä¼°è¯¦æƒ…æ¥å£ (`/api/v1/admin/evaluation_detail/{user_id}`) ä¸­è·å–ç”¨æˆ·ç­”é¢˜éŸ³é¢‘æ–‡ä»¶çš„å®Œæ•´æµç¨‹ï¼ŒåŒ…æ‹¬æ¥å£è°ƒç”¨ã€ä»£ç å®ç°å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ¯ åº”ç”¨åœºæ™¯

- **ä¸´åºŠè¯„ä¼°åˆ†æ**: åŒ»ç”Ÿå¬å–æ‚£è€…çœŸå®è¯­éŸ³è¿›è¡Œä¸“ä¸šè¯„ä¼°
- **è¯­è¨€åº·å¤è®­ç»ƒ**: åˆ†æç”¨æˆ·å‘éŸ³å’Œè¯­è¨€è¡¨è¾¾èƒ½åŠ›
- **æ•™å­¦è´¨é‡è¯„ä¼°**: è¯„ä¼°ç”¨æˆ·å­¦ä¹ æ•ˆæœå’Œè¯­è¨€è¿›æ­¥
- **ç ”ç©¶æ•°æ®é‡‡é›†**: æ”¶é›†è¯­éŸ³æ ·æœ¬ç”¨äºç§‘ç ”åˆ†æ

---

## ğŸ”— ç›¸å…³æ¥å£ä¿¡æ¯

### ä¸»è¦æ¶‰åŠæ¥å£

| æ¥å£ | ç”¨é€” | æƒé™è¦æ±‚ |
|------|------|----------|
| `GET /api/v1/admin/evaluation_detail/{user_id}` | è·å–è¯„ä¼°è¯¦æƒ…ï¼ˆåŒ…å«éŸ³é¢‘ä¿¡æ¯ï¼‰ | VIEWERåŠä»¥ä¸Š |
| `GET /api/v1/admin/audio/signed-url/{evaluation_id}` | è·å–éŸ³é¢‘è®¿é—®ç­¾åURL | VIEWERåŠä»¥ä¸Š |
| `GET /api/v1/admin/audio/stream/{evaluation_id}` | è·å–éŸ³é¢‘æµæ•°æ® | éŸ³é¢‘ä»¤ç‰Œè®¤è¯ |

---

## ğŸ“‹ å®Œæ•´è·å–æµç¨‹

### æ­¥éª¤1: è·å–è¯„ä¼°è¯¦æƒ…

#### è¯·æ±‚ç¤ºä¾‹
```http
GET /api/v1/admin/evaluation_detail/22?quiz_id=quiz_1760952972161
Authorization: Bearer {admin_token}
Content-Type: application/json
Host: 120.48.175.29:8001
```

#### å…³é”®å“åº”æ•°æ®
```json
{
  "success": true,
  "message": "è·å–è¯„ä¼°ç»“æœæˆåŠŸ",
  "data": {
    "assessment_info": [
      {
        "questions": [
          {
            "question_id": "q_007",
            "question_content": "è¯·ä½ å‘Šè¯‰æˆ‘ï¼Œä½ åœ¨è¿™ç”»ä¸­çœ‹è§ä»€ä¹ˆï¼Ÿ",
            "speaking_audio_info": {
              "has_audio": true,
              "requires_auth": true,
              "audio_info": "éŸ³é¢‘æ–‡ä»¶éœ€è¦é€šè¿‡å®‰å…¨æ¥å£è®¿é—®",
              "access_note": "è¯·å…ˆè°ƒç”¨ GET /api/v1/admin/audio/signed-url/{evaluation_id} è·å–ä¸´æ—¶è®¿é—®URL",
              "evaluation_id": 1137  // ğŸ”‘ å…³é”®ï¼šéŸ³é¢‘è®¿é—®ID
            }
          }
        ]
      }
    ]
  }
}
```

### æ­¥éª¤2: è·å–éŸ³é¢‘ç­¾åURL

#### è¯·æ±‚ç¤ºä¾‹
```http
GET /api/v1/admin/audio/signed-url/1137
Authorization: Bearer {admin_token}
Content-Type: application/json
```

#### å“åº”æ•°æ®
```json
{
  "success": true,
  "message": "éŸ³é¢‘ç­¾åURLç”ŸæˆæˆåŠŸ",
  "data": {
    "signed_url": "http://120.48.175.29:8001/api/v1/admin/audio/stream/1137",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",  // ğŸ”‘ éŸ³é¢‘è®¿é—®ä»¤ç‰Œ
    "expires_in": 3600,                                     // æœ‰æ•ˆæœŸï¼š1å°æ—¶
    "expires_at": "2025-10-21T11:18:31Z",
    "audio_duration": "53s",                                // éŸ³é¢‘æ—¶é•¿
    "file_size": "1.6MB"                                   // æ–‡ä»¶å¤§å°
  }
}
```

### æ­¥éª¤3: è·å–éŸ³é¢‘æµæ•°æ®

#### è¯·æ±‚ç¤ºä¾‹
```http
GET /api/v1/admin/audio/stream/1137
Authorization: Bearer {audio_token}  // æ³¨æ„ï¼šä½¿ç”¨éŸ³é¢‘ä»¤ç‰Œ
```

#### å“åº”
- **Content-Type**: `audio/wav`
- **Content-Length**: æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
- **Cache-Control**: `no-cache, no-store, must-revalidate`

---

## ğŸ’» å®Œæ•´ä»£ç å®ç°

### JavaScript/TypeScript å®ç°

```javascript
/**
 * è¯„ä¼°éŸ³é¢‘è·å–å·¥å…·ç±»
 */
class EvaluationAudioManager {
  constructor(baseUrl = 'http://120.48.175.29:8001', adminToken) {
    this.baseUrl = baseUrl;
    this.adminToken = adminToken;
    this.audioCache = new Map(); // éŸ³é¢‘ç¼“å­˜
  }

  /**
   * è·å–è¯„ä¼°è¯¦æƒ…ä¸­çš„æ‰€æœ‰éŸ³é¢‘
   * @param {string} userId - ç”¨æˆ·ID
   * @param {string} quizId - è¯•å·ID
   * @returns {Promise<Array>} éŸ³é¢‘ä¿¡æ¯åˆ—è¡¨
   */
  async getEvaluationAudioList(userId, quizId) {
    try {
      console.log(`ğŸ” å¼€å§‹è·å–ç”¨æˆ· ${userId} çš„è¯„ä¼°éŸ³é¢‘...`);
      
      // ç¬¬ä¸€æ­¥ï¼šè·å–è¯„ä¼°è¯¦æƒ…
      const evaluationData = await this.fetchEvaluationDetail(userId, quizId);
      
      // æå–éŸ³é¢‘ä¿¡æ¯
      const questions = evaluationData.data.assessment_info[0].questions;
      const audioPromises = questions
        .filter(q => q.speaking_audio_info?.has_audio)
        .map(q => this.processQuestionAudio(q));
      
      // å¹¶å‘è·å–æ‰€æœ‰éŸ³é¢‘
      const audioResults = await Promise.allSettled(audioPromises);
      
      // è¿‡æ»¤æˆåŠŸçš„ç»“æœ
      const successfulAudios = audioResults
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value);
      
      console.log(`âœ… æˆåŠŸè·å– ${successfulAudios.length} ä¸ªéŸ³é¢‘æ–‡ä»¶`);
      return successfulAudios;
      
    } catch (error) {
      console.error('âŒ è·å–è¯„ä¼°éŸ³é¢‘å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * è·å–è¯„ä¼°è¯¦æƒ…æ•°æ®
   */
  async fetchEvaluationDetail(userId, quizId) {
    const url = `${this.baseUrl}/api/v1/admin/evaluation_detail/${userId}?quiz_id=${quizId}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${this.adminToken}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`è·å–è¯„ä¼°è¯¦æƒ…å¤±è´¥: HTTP ${response.status}`);
    }

    return await response.json();
  }

  /**
   * å¤„ç†å•ä¸ªé¢˜ç›®çš„éŸ³é¢‘è·å–
   */
  async processQuestionAudio(question) {
    const audioInfo = question.speaking_audio_info;
    const evaluationId = audioInfo.evaluation_id;
    
    console.log(`ğŸµ å¤„ç†é¢˜ç›® ${question.question_id} çš„éŸ³é¢‘ (ID: ${evaluationId})`);
    
    try {
      // æ£€æŸ¥ç¼“å­˜
      if (this.audioCache.has(evaluationId)) {
        console.log(`ğŸ“‹ ä½¿ç”¨ç¼“å­˜éŸ³é¢‘: ${evaluationId}`);
        return this.audioCache.get(evaluationId);
      }
      
      // ç¬¬äºŒæ­¥ï¼šè·å–éŸ³é¢‘ç­¾åURL
      const signedUrlData = await this.getAudioSignedUrl(evaluationId);
      
      // ç¬¬ä¸‰æ­¥ï¼šè·å–éŸ³é¢‘æ•°æ®
      const audioBlob = await this.fetchAudioStream(
        signedUrlData.signed_url, 
        signedUrlData.token
      );
      
      // åˆ›å»ºéŸ³é¢‘URL
      const audioUrl = URL.createObjectURL(audioBlob);
      
      const audioResult = {
        questionId: question.question_id,
        questionContent: question.question_content,
        evaluationId: evaluationId,
        audioUrl: audioUrl,
        audioBlob: audioBlob,
        duration: signedUrlData.audio_duration,
        fileSize: signedUrlData.file_size,
        expiresAt: signedUrlData.expires_at,
        userAnswer: question.user_answer_text,
        createdTime: question.created_time
      };
      
      // ç¼“å­˜ç»“æœï¼ˆæ³¨æ„è¿‡æœŸæ—¶é—´ï¼‰
      this.audioCache.set(evaluationId, audioResult);
      
      console.log(`âœ… é¢˜ç›® ${question.question_id} éŸ³é¢‘è·å–æˆåŠŸ`);
      return audioResult;
      
    } catch (error) {
      console.warn(`âš ï¸ é¢˜ç›® ${question.question_id} éŸ³é¢‘è·å–å¤±è´¥:`, error.message);
      throw error;
    }
  }

  /**
   * è·å–éŸ³é¢‘ç­¾åURL
   */
  async getAudioSignedUrl(evaluationId) {
    const url = `${this.baseUrl}/api/v1/admin/audio/signed-url/${evaluationId}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${this.adminToken}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`è·å–éŸ³é¢‘ç­¾åURLå¤±è´¥: HTTP ${response.status}`);
    }

    const result = await response.json();
    
    if (!result.success) {
      throw new Error(`è·å–éŸ³é¢‘ç­¾åURLå¤±è´¥: ${result.message || 'æœªçŸ¥é”™è¯¯'}`);
    }

    return result.data;
  }

  /**
   * è·å–éŸ³é¢‘æµæ•°æ®
   */
  async fetchAudioStream(streamUrl, audioToken) {
    const response = await fetch(streamUrl, {
      headers: {
        'Authorization': `Bearer ${audioToken}`
      }
    });

    if (!response.ok) {
      throw new Error(`è·å–éŸ³é¢‘æµå¤±è´¥: HTTP ${response.status}`);
    }

    return await response.blob();
  }

  /**
   * æ¸…ç†éŸ³é¢‘èµ„æº
   */
  clearAudioCache() {
    this.audioCache.forEach(audio => {
      if (audio.audioUrl) {
        URL.revokeObjectURL(audio.audioUrl);
      }
    });
    this.audioCache.clear();
    console.log('ğŸ§¹ éŸ³é¢‘ç¼“å­˜å·²æ¸…ç†');
  }

  /**
   * æ’­æ”¾éŸ³é¢‘
   * @param {Object} audioData - éŸ³é¢‘æ•°æ®å¯¹è±¡
   * @returns {HTMLAudioElement} éŸ³é¢‘å…ƒç´ 
   */
  playAudio(audioData) {
    const audio = new Audio(audioData.audioUrl);
    
    audio.addEventListener('loadstart', () => {
      console.log(`ğŸµ å¼€å§‹åŠ è½½éŸ³é¢‘: ${audioData.questionId}`);
    });
    
    audio.addEventListener('canplaythrough', () => {
      console.log(`âœ… éŸ³é¢‘åŠ è½½å®Œæˆ: ${audioData.questionId}`);
    });
    
    audio.addEventListener('error', (e) => {
      console.error(`âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯: ${audioData.questionId}`, e);
    });
    
    audio.play().catch(error => {
      console.error(`æ’­æ”¾éŸ³é¢‘å¤±è´¥: ${audioData.questionId}`, error);
    });
    
    return audio;
  }

  /**
   * ä¸‹è½½éŸ³é¢‘æ–‡ä»¶
   */
  downloadAudio(audioData, filename = null) {
    const defaultFilename = `evaluation_${audioData.evaluationId}_${audioData.questionId}.wav`;
    const downloadFilename = filename || defaultFilename;
    
    const link = document.createElement('a');
    link.href = audioData.audioUrl;
    link.download = downloadFilename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log(`ğŸ“¥ éŸ³é¢‘ä¸‹è½½å·²å¼€å§‹: ${downloadFilename}`);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function example() {
  const audioManager = new EvaluationAudioManager(
    'http://120.48.175.29:8001',
    'your_admin_token_here'
  );

  try {
    // è·å–è¯„ä¼°éŸ³é¢‘
    const audioList = await audioManager.getEvaluationAudioList('22', 'quiz_1760952972161');
    
    console.log('è·å–åˆ°çš„éŸ³é¢‘åˆ—è¡¨:');
    audioList.forEach((audio, index) => {
      console.log(`${index + 1}. é¢˜ç›®: ${audio.questionContent}`);
      console.log(`   ç”¨æˆ·å›ç­”: ${audio.userAnswer}`);
      console.log(`   éŸ³é¢‘æ—¶é•¿: ${audio.duration}`);
      console.log(`   æ–‡ä»¶å¤§å°: ${audio.fileSize}`);
    });

    // æ’­æ”¾ç¬¬ä¸€ä¸ªéŸ³é¢‘
    if (audioList.length > 0) {
      audioManager.playAudio(audioList[0]);
    }

    // æ¸…ç†èµ„æºï¼ˆåœ¨é¡µé¢å¸è½½æ—¶è°ƒç”¨ï¼‰
    window.addEventListener('beforeunload', () => {
      audioManager.clearAudioCache();
    });

  } catch (error) {
    console.error('ç¤ºä¾‹æ‰§è¡Œå¤±è´¥:', error);
  }
}
```

### React Hook å®ç°

```jsx
import { useState, useEffect, useCallback, useRef } from 'react';

/**
 * React Hook: ç”¨äºç®¡ç†è¯„ä¼°éŸ³é¢‘
 */
function useEvaluationAudio(userId, quizId, adminToken) {
  const [audioList, setAudioList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [currentPlaying, setCurrentPlaying] = useState(null);
  
  const audioManagerRef = useRef(null);
  const audioElementsRef = useRef(new Map());

  // åˆå§‹åŒ–éŸ³é¢‘ç®¡ç†å™¨
  useEffect(() => {
    if (adminToken) {
      audioManagerRef.current = new EvaluationAudioManager(
        'http://120.48.175.29:8001',
        adminToken
      );
    }
  }, [adminToken]);

  // åŠ è½½éŸ³é¢‘åˆ—è¡¨
  const loadAudioList = useCallback(async () => {
    if (!audioManagerRef.current || !userId || !quizId) return;

    setLoading(true);
    setError(null);

    try {
      const audios = await audioManagerRef.current.getEvaluationAudioList(userId, quizId);
      setAudioList(audios);
    } catch (err) {
      setError(err.message);
      console.error('åŠ è½½éŸ³é¢‘åˆ—è¡¨å¤±è´¥:', err);
    } finally {
      setLoading(false);
    }
  }, [userId, quizId]);

  // æ’­æ”¾éŸ³é¢‘
  const playAudio = useCallback((audio) => {
    const questionId = audio.questionId;
    
    if (currentPlaying === questionId) {
      // æš‚åœå½“å‰æ’­æ”¾
      const element = audioElementsRef.current.get(questionId);
      element?.pause();
      setCurrentPlaying(null);
    } else {
      // åœæ­¢æ‰€æœ‰å…¶ä»–æ’­æ”¾
      audioElementsRef.current.forEach(el => el.pause());
      
      // åˆ›å»ºæˆ–è·å–éŸ³é¢‘å…ƒç´ 
      let audioElement = audioElementsRef.current.get(questionId);
      if (!audioElement) {
        audioElement = audioManagerRef.current.playAudio(audio);
        audioElement.addEventListener('ended', () => {
          setCurrentPlaying(null);
        });
        audioElementsRef.current.set(questionId, audioElement);
      }
      
      audioElement.play();
      setCurrentPlaying(questionId);
    }
  }, [currentPlaying]);

  // ä¸‹è½½éŸ³é¢‘
  const downloadAudio = useCallback((audio, filename) => {
    if (audioManagerRef.current) {
      audioManagerRef.current.downloadAudio(audio, filename);
    }
  }, []);

  // æ¸…ç†èµ„æº
  useEffect(() => {
    return () => {
      // åœæ­¢æ‰€æœ‰éŸ³é¢‘
      audioElementsRef.current.forEach(element => {
        element.pause();
        element.src = '';
      });
      audioElementsRef.current.clear();
      
      // æ¸…ç†éŸ³é¢‘ç®¡ç†å™¨
      if (audioManagerRef.current) {
        audioManagerRef.current.clearAudioCache();
      }
    };
  }, []);

  // è‡ªåŠ¨åŠ è½½
  useEffect(() => {
    loadAudioList();
  }, [loadAudioList]);

  return {
    audioList,
    loading,
    error,
    currentPlaying,
    playAudio,
    downloadAudio,
    reload: loadAudioList
  };
}

// React ç»„ä»¶ç¤ºä¾‹
function EvaluationAudioPlayer({ userId, quizId, adminToken }) {
  const {
    audioList,
    loading,
    error,
    currentPlaying,
    playAudio,
    downloadAudio,
    reload
  } = useEvaluationAudio(userId, quizId, adminToken);

  if (loading) {
    return <div className="loading">ğŸµ åŠ è½½éŸ³é¢‘ä¸­...</div>;
  }

  if (error) {
    return (
      <div className="error">
        âŒ åŠ è½½éŸ³é¢‘å¤±è´¥: {error}
        <button onClick={reload}>é‡è¯•</button>
      </div>
    );
  }

  return (
    <div className="evaluation-audio-player">
      <h3>è¯„ä¼°éŸ³é¢‘æ’­æ”¾å™¨ ({audioList.length} ä¸ªéŸ³é¢‘)</h3>
      
      {audioList.map((audio, index) => (
        <div key={audio.questionId} className="audio-item">
          <div className="question-header">
            <h4>é¢˜ç›® {index + 1}: {audio.questionContent}</h4>
            <div className="audio-meta">
              æ—¶é•¿: {audio.duration} | å¤§å°: {audio.fileSize}
            </div>
          </div>
          
          <div className="user-answer">
            <strong>ç”¨æˆ·å›ç­”:</strong> {audio.userAnswer}
          </div>
          
          <div className="audio-controls">
            <button
              onClick={() => playAudio(audio)}
              className={currentPlaying === audio.questionId ? 'playing' : ''}
            >
              {currentPlaying === audio.questionId ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾'}
            </button>
            
            <button onClick={() => downloadAudio(audio)}>
              ğŸ“¥ ä¸‹è½½
            </button>
          </div>
          
          <div className="created-time">
            è¯„ä¼°æ—¶é—´: {new Date(audio.createdTime).toLocaleString()}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### Vue.js ç»„åˆå¼APIå®ç°

```vue
<template>
  <div class="evaluation-audio-player">
    <h3>è¯„ä¼°éŸ³é¢‘æ’­æ”¾å™¨</h3>
    
    <div v-if="loading" class="loading">
      ğŸµ åŠ è½½éŸ³é¢‘ä¸­...
    </div>
    
    <div v-else-if="error" class="error">
      âŒ åŠ è½½éŸ³é¢‘å¤±è´¥: {{ error }}
      <button @click="reload">é‡è¯•</button>
    </div>
    
    <div v-else class="audio-list">
      <div
        v-for="(audio, index) in audioList"
        :key="audio.questionId"
        class="audio-item"
      >
        <div class="question-header">
          <h4>é¢˜ç›® {{ index + 1 }}: {{ audio.questionContent }}</h4>
          <div class="audio-meta">
            æ—¶é•¿: {{ audio.duration }} | å¤§å°: {{ audio.fileSize }}
          </div>
        </div>
        
        <div class="user-answer">
          <strong>ç”¨æˆ·å›ç­”:</strong> {{ audio.userAnswer }}
        </div>
        
        <div class="audio-controls">
          <button
            @click="playAudio(audio)"
            :class="{ playing: currentPlaying === audio.questionId }"
          >
            {{ currentPlaying === audio.questionId ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾' }}
          </button>
          
          <button @click="downloadAudio(audio)">
            ğŸ“¥ ä¸‹è½½
          </button>
        </div>
        
        <div class="created-time">
          è¯„ä¼°æ—¶é—´: {{ formatTime(audio.createdTime) }}
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

// Props
const props = defineProps({
  userId: String,
  quizId: String,
  adminToken: String
})

// å“åº”å¼æ•°æ®
const audioList = ref([])
const loading = ref(false)
const error = ref(null)
const currentPlaying = ref(null)

// éŸ³é¢‘ç®¡ç†å™¨å’Œå…ƒç´ 
let audioManager = null
const audioElements = new Map()

// åˆå§‹åŒ–
onMounted(async () => {
  audioManager = new EvaluationAudioManager(
    'http://120.48.175.29:8001',
    props.adminToken
  )
  await loadAudioList()
})

// æ¸…ç†
onUnmounted(() => {
  audioElements.forEach(element => {
    element.pause()
    element.src = ''
  })
  audioElements.clear()
  
  if (audioManager) {
    audioManager.clearAudioCache()
  }
})

// æ–¹æ³•
async function loadAudioList() {
  if (!audioManager || !props.userId || !props.quizId) return

  loading.value = true
  error.value = null

  try {
    const audios = await audioManager.getEvaluationAudioList(props.userId, props.quizId)
    audioList.value = audios
  } catch (err) {
    error.value = err.message
    console.error('åŠ è½½éŸ³é¢‘åˆ—è¡¨å¤±è´¥:', err)
  } finally {
    loading.value = false
  }
}

function playAudio(audio) {
  const questionId = audio.questionId
  
  if (currentPlaying.value === questionId) {
    // æš‚åœå½“å‰æ’­æ”¾
    const element = audioElements.get(questionId)
    element?.pause()
    currentPlaying.value = null
  } else {
    // åœæ­¢æ‰€æœ‰å…¶ä»–æ’­æ”¾
    audioElements.forEach(el => el.pause())
    
    // åˆ›å»ºæˆ–è·å–éŸ³é¢‘å…ƒç´ 
    let audioElement = audioElements.get(questionId)
    if (!audioElement) {
      audioElement = audioManager.playAudio(audio)
      audioElement.addEventListener('ended', () => {
        currentPlaying.value = null
      })
      audioElements.set(questionId, audioElement)
    }
    
    audioElement.play()
    currentPlaying.value = questionId
  }
}

function downloadAudio(audio) {
  if (audioManager) {
    audioManager.downloadAudio(audio)
  }
}

function formatTime(timeString) {
  return new Date(timeString).toLocaleString()
}

function reload() {
  loadAudioList()
}
</script>

<style scoped>
.evaluation-audio-player {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.audio-item {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  background: #f9f9f9;
}

.question-header h4 {
  margin: 0 0 8px 0;
  color: #333;
}

.audio-meta {
  font-size: 12px;
  color: #666;
}

.user-answer {
  margin: 12px 0;
  padding: 8px;
  background: #fff;
  border-radius: 4px;
  border-left: 3px solid #007bff;
}

.audio-controls {
  display: flex;
  gap: 8px;
  margin: 12px 0;
}

.audio-controls button {
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  transition: all 0.2s;
}

.audio-controls button:hover {
  background: #f0f0f0;
}

.audio-controls button.playing {
  background: #007bff;
  color: white;
}

.created-time {
  font-size: 12px;
  color: #999;
}

.loading, .error {
  text-align: center;
  padding: 20px;
}

.error button {
  margin-left: 8px;
  padding: 4px 8px;
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

---

## âš ï¸ é‡è¦æ³¨æ„äº‹é¡¹

### 1. **ä»¤ç‰Œç®¡ç†**
- **ç®¡ç†å‘˜ä»¤ç‰Œ**: ç”¨äºè·å–è¯„ä¼°è¯¦æƒ…å’ŒéŸ³é¢‘ç­¾åURL
- **éŸ³é¢‘ä»¤ç‰Œ**: ç”¨äºè®¿é—®å®é™…éŸ³é¢‘æµï¼Œæœ‰æ•ˆæœŸ1å°æ—¶
- **ä»¤ç‰Œæ›´æ–°**: éŸ³é¢‘ä»¤ç‰Œè¿‡æœŸåéœ€è¦é‡æ–°è·å–ç­¾åURL

### 2. **é”™è¯¯å¤„ç†**
```javascript
// æ ‡å‡†é”™è¯¯å¤„ç†æ¨¡å¼
try {
  // éŸ³é¢‘è·å–é€»è¾‘
} catch (error) {
  switch (true) {
    case error.message.includes('401'):
      console.error('è®¤è¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•');
      break;
    case error.message.includes('403'):
      console.error('æƒé™ä¸è¶³ï¼Œè¯·è”ç³»ç®¡ç†å‘˜');
      break;
    case error.message.includes('404'):
      console.error('éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²åˆ é™¤');
      break;
    case error.message.includes('500'):
      console.error('æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
      break;
    default:
      console.error('æœªçŸ¥é”™è¯¯:', error.message);
  }
}
```

### 3. **æ€§èƒ½ä¼˜åŒ–**

#### ç¼“å­˜ç­–ç•¥
```javascript
// å®ç°éŸ³é¢‘ç¼“å­˜æœºåˆ¶
const audioCache = new Map();
const CACHE_EXPIRE_TIME = 30 * 60 * 1000; // 30åˆ†é’Ÿ

function cacheAudio(evaluationId, audioData) {
  audioCache.set(evaluationId, {
    data: audioData,
    timestamp: Date.now()
  });
}

function getCachedAudio(evaluationId) {
  const cached = audioCache.get(evaluationId);
  if (cached && Date.now() - cached.timestamp < CACHE_EXPIRE_TIME) {
    return cached.data;
  }
  audioCache.delete(evaluationId);
  return null;
}
```

#### å¹¶å‘æ§åˆ¶
```javascript
// é™åˆ¶å¹¶å‘è¯·æ±‚æ•°é‡
const CONCURRENT_LIMIT = 3;

async function fetchAudiosWithLimit(audioRequests) {
  const results = [];
  
  for (let i = 0; i < audioRequests.length; i += CONCURRENT_LIMIT) {
    const batch = audioRequests.slice(i, i + CONCURRENT_LIMIT);
    const batchResults = await Promise.allSettled(batch);
    results.push(...batchResults);
  }
  
  return results;
}
```

### 4. **å†…å­˜ç®¡ç†**
```javascript
// åŠæ—¶æ¸…ç†Blob URLs
function cleanupAudioResources(audioList) {
  audioList.forEach(audio => {
    if (audio.audioUrl) {
      URL.revokeObjectURL(audio.audioUrl);
    }
  });
}

// é¡µé¢å¸è½½æ—¶æ¸…ç†
window.addEventListener('beforeunload', () => {
  cleanupAudioResources(audioList);
});
```

### 5. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**

#### åŠ è½½çŠ¶æ€ç®¡ç†
```javascript
// æ˜¾ç¤ºè¯¦ç»†çš„åŠ è½½è¿›åº¦
function showProgress(current, total, message) {
  const percentage = Math.round((current / total) * 100);
  console.log(`ğŸ“Š ${message}: ${current}/${total} (${percentage}%)`);
  
  // æ›´æ–°UIè¿›åº¦æ¡
  updateProgressBar(percentage);
}
```

#### é”™è¯¯é‡è¯•æœºåˆ¶
```javascript
// å®ç°è‡ªåŠ¨é‡è¯•
async function fetchWithRetry(fetchFunction, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchFunction();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      console.warn(`é‡è¯• ${i + 1}/${maxRetries}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }
}
```

---

## ğŸ”§ æœ€ä½³å®è·µ

### 1. **å®‰å…¨æ€§**
- å§‹ç»ˆä½¿ç”¨HTTPSä¼ è¾“éŸ³é¢‘æ•°æ®
- ä¸è¦å°†éŸ³é¢‘ä»¤ç‰Œå­˜å‚¨åœ¨æœ¬åœ°å­˜å‚¨ä¸­
- å®šæœŸæ£€æŸ¥ä»¤ç‰Œæœ‰æ•ˆæœŸå¹¶åŠæ—¶æ›´æ–°

### 2. **æ€§èƒ½**
- å®ç°éŸ³é¢‘é¢„åŠ è½½æœºåˆ¶
- ä½¿ç”¨Web Workerså¤„ç†å¤§é‡éŸ³é¢‘æ•°æ®
- å¯ç”¨éŸ³é¢‘å‹ç¼©ä¼ è¾“

### 3. **ç”¨æˆ·ä½“éªŒ**
- æä¾›éŸ³é¢‘åŠ è½½è¿›åº¦æç¤º
- æ”¯æŒéŸ³é¢‘æ’­æ”¾æ§åˆ¶ï¼ˆæ’­æ”¾/æš‚åœ/è¿›åº¦æ¡ï¼‰
- å®ç°éŸ³é¢‘ä¸‹è½½åŠŸèƒ½

### 4. **é”™è¯¯å¤„ç†**
- æä¾›å‹å¥½çš„é”™è¯¯æç¤ºä¿¡æ¯
- å®ç°è‡ªåŠ¨é‡è¯•æœºåˆ¶
- è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—ç”¨äºè°ƒè¯•

---

## ğŸš€ æ‰©å±•åŠŸèƒ½

### 1. **æ‰¹é‡ä¸‹è½½**
```javascript
async function batchDownloadAudios(audioList, zipFilename = 'evaluation_audios.zip') {
  const JSZip = require('jszip');
  const zip = new JSZip();
  
  for (const audio of audioList) {
    const filename = `${audio.questionId}_${audio.evaluationId}.wav`;
    zip.file(filename, audio.audioBlob);
  }
  
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  
  const link = document.createElement('a');
  link.href = URL.createObjectURL(zipBlob);
  link.download = zipFilename;
  link.click();
}
```

### 2. **éŸ³é¢‘å¯è§†åŒ–**
```javascript
// ä½¿ç”¨Web Audio APIå®ç°éŸ³é¢‘æ³¢å½¢æ˜¾ç¤º
function createAudioVisualizer(audioElement, canvasElement) {
  const audioContext = new AudioContext();
  const analyser = audioContext.createAnalyser();
  const source = audioContext.createMediaElementSource(audioElement);
  
  source.connect(analyser);
  analyser.connect(audioContext.destination);
  
  analyser.fftSize = 256;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  function draw() {
    requestAnimationFrame(draw);
    
    analyser.getByteFrequencyData(dataArray);
    
    const canvas = canvasElement;
    const canvasCtx = canvas.getContext('2d');
    
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    
    const barWidth = (canvas.width / bufferLength) * 2.5;
    let barHeight;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      barHeight = dataArray[i] / 2;
      
      canvasCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
      canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
      
      x += barWidth + 1;
    }
  }
  
  draw();
}
```

### 3. **éŸ³é¢‘åˆ†æ**
```javascript
// åˆ†æéŸ³é¢‘ç‰¹å¾ï¼ˆæ—¶é•¿ã€éŸ³é‡ç­‰ï¼‰
async function analyzeAudio(audioBlob) {
  return new Promise((resolve) => {
    const audio = new Audio();
    const url = URL.createObjectURL(audioBlob);
    
    audio.addEventListener('loadedmetadata', () => {
      const analysis = {
        duration: audio.duration,
        fileSize: audioBlob.size,
        format: audioBlob.type,
        bitRate: Math.round((audioBlob.size * 8) / audio.duration / 1000), // kbps
        sampleRate: null // éœ€è¦Web Audio APIè·å–
      };
      
      URL.revokeObjectURL(url);
      resolve(analysis);
    });
    
    audio.src = url;
  });
}
```

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰ä»»ä½•é—®é¢˜æˆ–éœ€è¦æŠ€æœ¯æ”¯æŒï¼Œè¯·å‚è€ƒä»¥ä¸‹èµ„æºï¼š

- **APIæ–‡æ¡£**: [å®Œæ•´APIå‚è€ƒæ–‡æ¡£](./API_DOCUMENTATION.md)
- **éŸ³é¢‘æ¥å£æŒ‡å—**: [éŸ³é¢‘APIå‰ç«¯ä½¿ç”¨æŒ‡å—](./AUDIO_API_FRONTEND_GUIDE.md)
- **é”™è¯¯æ’æŸ¥**: [å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ](./TROUBLESHOOTING.md)

---

## ğŸ“ æ›´æ–°æ—¥å¿—

### v1.0.0 (2025-10-21)
- âœ… å®Œæˆè¯„ä¼°è¯¦æƒ…éŸ³é¢‘è·å–å®Œæ•´æµç¨‹æ–‡æ¡£
- âœ… æä¾›JavaScript/TypeScriptå®Œæ•´å®ç°
- âœ… æ·»åŠ Reactå’ŒVue.jsç»„ä»¶ç¤ºä¾‹
- âœ… åŒ…å«é”™è¯¯å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–å»ºè®®
- âœ… æä¾›æ‰©å±•åŠŸèƒ½å®ç°æ–¹æ¡ˆ
