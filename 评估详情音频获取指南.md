# 📋 评估详情音频获取完整指南

## 📖 文档概述

本文档详细说明如何从评估详情接口 (`/api/v1/admin/evaluation_detail/{user_id}`) 中获取用户答题音频文件的完整流程，包括接口调用、代码实现和最佳实践。

---

## 🎯 应用场景

- **临床评估分析**: 医生听取患者真实语音进行专业评估
- **语言康复训练**: 分析用户发音和语言表达能力
- **教学质量评估**: 评估用户学习效果和语言进步
- **研究数据采集**: 收集语音样本用于科研分析

---

## 🔗 相关接口信息

### 主要涉及接口

| 接口 | 用途 | 权限要求 |
|------|------|----------|
| `GET /api/v1/admin/evaluation_detail/{user_id}` | 获取评估详情（包含音频信息） | VIEWER及以上 |
| `GET /api/v1/admin/audio/signed-url/{evaluation_id}` | 获取音频访问签名URL | VIEWER及以上 |
| `GET /api/v1/admin/audio/stream/{evaluation_id}` | 获取音频流数据 | 音频令牌认证 |

---

## 📋 完整获取流程

### 步骤1: 获取评估详情

#### 请求示例
```http
GET /api/v1/admin/evaluation_detail/22?quiz_id=quiz_1760952972161
Authorization: Bearer {admin_token}
Content-Type: application/json
Host: 120.48.175.29:8001
```

#### 关键响应数据
```json
{
  "success": true,
  "message": "获取评估结果成功",
  "data": {
    "assessment_info": [
      {
        "questions": [
          {
            "question_id": "q_007",
            "question_content": "请你告诉我，你在这画中看见什么？",
            "speaking_audio_info": {
              "has_audio": true,
              "requires_auth": true,
              "audio_info": "音频文件需要通过安全接口访问",
              "access_note": "请先调用 GET /api/v1/admin/audio/signed-url/{evaluation_id} 获取临时访问URL",
              "evaluation_id": 1137  // 🔑 关键：音频访问ID
            }
          }
        ]
      }
    ]
  }
}
```

### 步骤2: 获取音频签名URL

#### 请求示例
```http
GET /api/v1/admin/audio/signed-url/1137
Authorization: Bearer {admin_token}
Content-Type: application/json
```

#### 响应数据
```json
{
  "success": true,
  "message": "音频签名URL生成成功",
  "data": {
    "signed_url": "http://120.48.175.29:8001/api/v1/admin/audio/stream/1137",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",  // 🔑 音频访问令牌
    "expires_in": 3600,                                     // 有效期：1小时
    "expires_at": "2025-10-21T11:18:31Z",
    "audio_duration": "53s",                                // 音频时长
    "file_size": "1.6MB"                                   // 文件大小
  }
}
```

### 步骤3: 获取音频流数据

#### 请求示例
```http
GET /api/v1/admin/audio/stream/1137
Authorization: Bearer {audio_token}  // 注意：使用音频令牌
```

#### 响应
- **Content-Type**: `audio/wav`
- **Content-Length**: 文件大小（字节）
- **Cache-Control**: `no-cache, no-store, must-revalidate`

---

## 💻 完整代码实现

### JavaScript/TypeScript 实现

```javascript
/**
 * 评估音频获取工具类
 */
class EvaluationAudioManager {
  constructor(baseUrl = 'http://120.48.175.29:8001', adminToken) {
    this.baseUrl = baseUrl;
    this.adminToken = adminToken;
    this.audioCache = new Map(); // 音频缓存
  }

  /**
   * 获取评估详情中的所有音频
   * @param {string} userId - 用户ID
   * @param {string} quizId - 试卷ID
   * @returns {Promise<Array>} 音频信息列表
   */
  async getEvaluationAudioList(userId, quizId) {
    try {
      console.log(`🔍 开始获取用户 ${userId} 的评估音频...`);
      
      // 第一步：获取评估详情
      const evaluationData = await this.fetchEvaluationDetail(userId, quizId);
      
      // 提取音频信息
      const questions = evaluationData.data.assessment_info[0].questions;
      const audioPromises = questions
        .filter(q => q.speaking_audio_info?.has_audio)
        .map(q => this.processQuestionAudio(q));
      
      // 并发获取所有音频
      const audioResults = await Promise.allSettled(audioPromises);
      
      // 过滤成功的结果
      const successfulAudios = audioResults
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value);
      
      console.log(`✅ 成功获取 ${successfulAudios.length} 个音频文件`);
      return successfulAudios;
      
    } catch (error) {
      console.error('❌ 获取评估音频失败:', error);
      throw error;
    }
  }

  /**
   * 获取评估详情数据
   */
  async fetchEvaluationDetail(userId, quizId) {
    const url = `${this.baseUrl}/api/v1/admin/evaluation_detail/${userId}?quiz_id=${quizId}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${this.adminToken}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`获取评估详情失败: HTTP ${response.status}`);
    }

    return await response.json();
  }

  /**
   * 处理单个题目的音频获取
   */
  async processQuestionAudio(question) {
    const audioInfo = question.speaking_audio_info;
    const evaluationId = audioInfo.evaluation_id;
    
    console.log(`🎵 处理题目 ${question.question_id} 的音频 (ID: ${evaluationId})`);
    
    try {
      // 检查缓存
      if (this.audioCache.has(evaluationId)) {
        console.log(`📋 使用缓存音频: ${evaluationId}`);
        return this.audioCache.get(evaluationId);
      }
      
      // 第二步：获取音频签名URL
      const signedUrlData = await this.getAudioSignedUrl(evaluationId);
      
      // 第三步：获取音频数据
      const audioBlob = await this.fetchAudioStream(
        signedUrlData.signed_url, 
        signedUrlData.token
      );
      
      // 创建音频URL
      const audioUrl = URL.createObjectURL(audioBlob);
      
      const audioResult = {
        questionId: question.question_id,
        questionContent: question.question_content,
        evaluationId: evaluationId,
        audioUrl: audioUrl,
        audioBlob: audioBlob,
        duration: signedUrlData.audio_duration,
        fileSize: signedUrlData.file_size,
        expiresAt: signedUrlData.expires_at,
        userAnswer: question.user_answer_text,
        createdTime: question.created_time
      };
      
      // 缓存结果（注意过期时间）
      this.audioCache.set(evaluationId, audioResult);
      
      console.log(`✅ 题目 ${question.question_id} 音频获取成功`);
      return audioResult;
      
    } catch (error) {
      console.warn(`⚠️ 题目 ${question.question_id} 音频获取失败:`, error.message);
      throw error;
    }
  }

  /**
   * 获取音频签名URL
   */
  async getAudioSignedUrl(evaluationId) {
    const url = `${this.baseUrl}/api/v1/admin/audio/signed-url/${evaluationId}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${this.adminToken}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`获取音频签名URL失败: HTTP ${response.status}`);
    }

    const result = await response.json();
    
    if (!result.success) {
      throw new Error(`获取音频签名URL失败: ${result.message || '未知错误'}`);
    }

    return result.data;
  }

  /**
   * 获取音频流数据
   */
  async fetchAudioStream(streamUrl, audioToken) {
    const response = await fetch(streamUrl, {
      headers: {
        'Authorization': `Bearer ${audioToken}`
      }
    });

    if (!response.ok) {
      throw new Error(`获取音频流失败: HTTP ${response.status}`);
    }

    return await response.blob();
  }

  /**
   * 清理音频资源
   */
  clearAudioCache() {
    this.audioCache.forEach(audio => {
      if (audio.audioUrl) {
        URL.revokeObjectURL(audio.audioUrl);
      }
    });
    this.audioCache.clear();
    console.log('🧹 音频缓存已清理');
  }

  /**
   * 播放音频
   * @param {Object} audioData - 音频数据对象
   * @returns {HTMLAudioElement} 音频元素
   */
  playAudio(audioData) {
    const audio = new Audio(audioData.audioUrl);
    
    audio.addEventListener('loadstart', () => {
      console.log(`🎵 开始加载音频: ${audioData.questionId}`);
    });
    
    audio.addEventListener('canplaythrough', () => {
      console.log(`✅ 音频加载完成: ${audioData.questionId}`);
    });
    
    audio.addEventListener('error', (e) => {
      console.error(`❌ 音频播放错误: ${audioData.questionId}`, e);
    });
    
    audio.play().catch(error => {
      console.error(`播放音频失败: ${audioData.questionId}`, error);
    });
    
    return audio;
  }

  /**
   * 下载音频文件
   */
  downloadAudio(audioData, filename = null) {
    const defaultFilename = `evaluation_${audioData.evaluationId}_${audioData.questionId}.wav`;
    const downloadFilename = filename || defaultFilename;
    
    const link = document.createElement('a');
    link.href = audioData.audioUrl;
    link.download = downloadFilename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log(`📥 音频下载已开始: ${downloadFilename}`);
  }
}

// 使用示例
async function example() {
  const audioManager = new EvaluationAudioManager(
    'http://120.48.175.29:8001',
    'your_admin_token_here'
  );

  try {
    // 获取评估音频
    const audioList = await audioManager.getEvaluationAudioList('22', 'quiz_1760952972161');
    
    console.log('获取到的音频列表:');
    audioList.forEach((audio, index) => {
      console.log(`${index + 1}. 题目: ${audio.questionContent}`);
      console.log(`   用户回答: ${audio.userAnswer}`);
      console.log(`   音频时长: ${audio.duration}`);
      console.log(`   文件大小: ${audio.fileSize}`);
    });

    // 播放第一个音频
    if (audioList.length > 0) {
      audioManager.playAudio(audioList[0]);
    }

    // 清理资源（在页面卸载时调用）
    window.addEventListener('beforeunload', () => {
      audioManager.clearAudioCache();
    });

  } catch (error) {
    console.error('示例执行失败:', error);
  }
}
```

### React Hook 实现

```jsx
import { useState, useEffect, useCallback, useRef } from 'react';

/**
 * React Hook: 用于管理评估音频
 */
function useEvaluationAudio(userId, quizId, adminToken) {
  const [audioList, setAudioList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [currentPlaying, setCurrentPlaying] = useState(null);
  
  const audioManagerRef = useRef(null);
  const audioElementsRef = useRef(new Map());

  // 初始化音频管理器
  useEffect(() => {
    if (adminToken) {
      audioManagerRef.current = new EvaluationAudioManager(
        'http://120.48.175.29:8001',
        adminToken
      );
    }
  }, [adminToken]);

  // 加载音频列表
  const loadAudioList = useCallback(async () => {
    if (!audioManagerRef.current || !userId || !quizId) return;

    setLoading(true);
    setError(null);

    try {
      const audios = await audioManagerRef.current.getEvaluationAudioList(userId, quizId);
      setAudioList(audios);
    } catch (err) {
      setError(err.message);
      console.error('加载音频列表失败:', err);
    } finally {
      setLoading(false);
    }
  }, [userId, quizId]);

  // 播放音频
  const playAudio = useCallback((audio) => {
    const questionId = audio.questionId;
    
    if (currentPlaying === questionId) {
      // 暂停当前播放
      const element = audioElementsRef.current.get(questionId);
      element?.pause();
      setCurrentPlaying(null);
    } else {
      // 停止所有其他播放
      audioElementsRef.current.forEach(el => el.pause());
      
      // 创建或获取音频元素
      let audioElement = audioElementsRef.current.get(questionId);
      if (!audioElement) {
        audioElement = audioManagerRef.current.playAudio(audio);
        audioElement.addEventListener('ended', () => {
          setCurrentPlaying(null);
        });
        audioElementsRef.current.set(questionId, audioElement);
      }
      
      audioElement.play();
      setCurrentPlaying(questionId);
    }
  }, [currentPlaying]);

  // 下载音频
  const downloadAudio = useCallback((audio, filename) => {
    if (audioManagerRef.current) {
      audioManagerRef.current.downloadAudio(audio, filename);
    }
  }, []);

  // 清理资源
  useEffect(() => {
    return () => {
      // 停止所有音频
      audioElementsRef.current.forEach(element => {
        element.pause();
        element.src = '';
      });
      audioElementsRef.current.clear();
      
      // 清理音频管理器
      if (audioManagerRef.current) {
        audioManagerRef.current.clearAudioCache();
      }
    };
  }, []);

  // 自动加载
  useEffect(() => {
    loadAudioList();
  }, [loadAudioList]);

  return {
    audioList,
    loading,
    error,
    currentPlaying,
    playAudio,
    downloadAudio,
    reload: loadAudioList
  };
}

// React 组件示例
function EvaluationAudioPlayer({ userId, quizId, adminToken }) {
  const {
    audioList,
    loading,
    error,
    currentPlaying,
    playAudio,
    downloadAudio,
    reload
  } = useEvaluationAudio(userId, quizId, adminToken);

  if (loading) {
    return <div className="loading">🎵 加载音频中...</div>;
  }

  if (error) {
    return (
      <div className="error">
        ❌ 加载音频失败: {error}
        <button onClick={reload}>重试</button>
      </div>
    );
  }

  return (
    <div className="evaluation-audio-player">
      <h3>评估音频播放器 ({audioList.length} 个音频)</h3>
      
      {audioList.map((audio, index) => (
        <div key={audio.questionId} className="audio-item">
          <div className="question-header">
            <h4>题目 {index + 1}: {audio.questionContent}</h4>
            <div className="audio-meta">
              时长: {audio.duration} | 大小: {audio.fileSize}
            </div>
          </div>
          
          <div className="user-answer">
            <strong>用户回答:</strong> {audio.userAnswer}
          </div>
          
          <div className="audio-controls">
            <button
              onClick={() => playAudio(audio)}
              className={currentPlaying === audio.questionId ? 'playing' : ''}
            >
              {currentPlaying === audio.questionId ? '⏸️ 暂停' : '▶️ 播放'}
            </button>
            
            <button onClick={() => downloadAudio(audio)}>
              📥 下载
            </button>
          </div>
          
          <div className="created-time">
            评估时间: {new Date(audio.createdTime).toLocaleString()}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### Vue.js 组合式API实现

```vue
<template>
  <div class="evaluation-audio-player">
    <h3>评估音频播放器</h3>
    
    <div v-if="loading" class="loading">
      🎵 加载音频中...
    </div>
    
    <div v-else-if="error" class="error">
      ❌ 加载音频失败: {{ error }}
      <button @click="reload">重试</button>
    </div>
    
    <div v-else class="audio-list">
      <div
        v-for="(audio, index) in audioList"
        :key="audio.questionId"
        class="audio-item"
      >
        <div class="question-header">
          <h4>题目 {{ index + 1 }}: {{ audio.questionContent }}</h4>
          <div class="audio-meta">
            时长: {{ audio.duration }} | 大小: {{ audio.fileSize }}
          </div>
        </div>
        
        <div class="user-answer">
          <strong>用户回答:</strong> {{ audio.userAnswer }}
        </div>
        
        <div class="audio-controls">
          <button
            @click="playAudio(audio)"
            :class="{ playing: currentPlaying === audio.questionId }"
          >
            {{ currentPlaying === audio.questionId ? '⏸️ 暂停' : '▶️ 播放' }}
          </button>
          
          <button @click="downloadAudio(audio)">
            📥 下载
          </button>
        </div>
        
        <div class="created-time">
          评估时间: {{ formatTime(audio.createdTime) }}
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

// Props
const props = defineProps({
  userId: String,
  quizId: String,
  adminToken: String
})

// 响应式数据
const audioList = ref([])
const loading = ref(false)
const error = ref(null)
const currentPlaying = ref(null)

// 音频管理器和元素
let audioManager = null
const audioElements = new Map()

// 初始化
onMounted(async () => {
  audioManager = new EvaluationAudioManager(
    'http://120.48.175.29:8001',
    props.adminToken
  )
  await loadAudioList()
})

// 清理
onUnmounted(() => {
  audioElements.forEach(element => {
    element.pause()
    element.src = ''
  })
  audioElements.clear()
  
  if (audioManager) {
    audioManager.clearAudioCache()
  }
})

// 方法
async function loadAudioList() {
  if (!audioManager || !props.userId || !props.quizId) return

  loading.value = true
  error.value = null

  try {
    const audios = await audioManager.getEvaluationAudioList(props.userId, props.quizId)
    audioList.value = audios
  } catch (err) {
    error.value = err.message
    console.error('加载音频列表失败:', err)
  } finally {
    loading.value = false
  }
}

function playAudio(audio) {
  const questionId = audio.questionId
  
  if (currentPlaying.value === questionId) {
    // 暂停当前播放
    const element = audioElements.get(questionId)
    element?.pause()
    currentPlaying.value = null
  } else {
    // 停止所有其他播放
    audioElements.forEach(el => el.pause())
    
    // 创建或获取音频元素
    let audioElement = audioElements.get(questionId)
    if (!audioElement) {
      audioElement = audioManager.playAudio(audio)
      audioElement.addEventListener('ended', () => {
        currentPlaying.value = null
      })
      audioElements.set(questionId, audioElement)
    }
    
    audioElement.play()
    currentPlaying.value = questionId
  }
}

function downloadAudio(audio) {
  if (audioManager) {
    audioManager.downloadAudio(audio)
  }
}

function formatTime(timeString) {
  return new Date(timeString).toLocaleString()
}

function reload() {
  loadAudioList()
}
</script>

<style scoped>
.evaluation-audio-player {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.audio-item {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  background: #f9f9f9;
}

.question-header h4 {
  margin: 0 0 8px 0;
  color: #333;
}

.audio-meta {
  font-size: 12px;
  color: #666;
}

.user-answer {
  margin: 12px 0;
  padding: 8px;
  background: #fff;
  border-radius: 4px;
  border-left: 3px solid #007bff;
}

.audio-controls {
  display: flex;
  gap: 8px;
  margin: 12px 0;
}

.audio-controls button {
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  transition: all 0.2s;
}

.audio-controls button:hover {
  background: #f0f0f0;
}

.audio-controls button.playing {
  background: #007bff;
  color: white;
}

.created-time {
  font-size: 12px;
  color: #999;
}

.loading, .error {
  text-align: center;
  padding: 20px;
}

.error button {
  margin-left: 8px;
  padding: 4px 8px;
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

---

## ⚠️ 重要注意事项

### 1. **令牌管理**
- **管理员令牌**: 用于获取评估详情和音频签名URL
- **音频令牌**: 用于访问实际音频流，有效期1小时
- **令牌更新**: 音频令牌过期后需要重新获取签名URL

### 2. **错误处理**
```javascript
// 标准错误处理模式
try {
  // 音频获取逻辑
} catch (error) {
  switch (true) {
    case error.message.includes('401'):
      console.error('认证失败，请重新登录');
      break;
    case error.message.includes('403'):
      console.error('权限不足，请联系管理员');
      break;
    case error.message.includes('404'):
      console.error('音频文件不存在或已删除');
      break;
    case error.message.includes('500'):
      console.error('服务器错误，请稍后重试');
      break;
    default:
      console.error('未知错误:', error.message);
  }
}
```

### 3. **性能优化**

#### 缓存策略
```javascript
// 实现音频缓存机制
const audioCache = new Map();
const CACHE_EXPIRE_TIME = 30 * 60 * 1000; // 30分钟

function cacheAudio(evaluationId, audioData) {
  audioCache.set(evaluationId, {
    data: audioData,
    timestamp: Date.now()
  });
}

function getCachedAudio(evaluationId) {
  const cached = audioCache.get(evaluationId);
  if (cached && Date.now() - cached.timestamp < CACHE_EXPIRE_TIME) {
    return cached.data;
  }
  audioCache.delete(evaluationId);
  return null;
}
```

#### 并发控制
```javascript
// 限制并发请求数量
const CONCURRENT_LIMIT = 3;

async function fetchAudiosWithLimit(audioRequests) {
  const results = [];
  
  for (let i = 0; i < audioRequests.length; i += CONCURRENT_LIMIT) {
    const batch = audioRequests.slice(i, i + CONCURRENT_LIMIT);
    const batchResults = await Promise.allSettled(batch);
    results.push(...batchResults);
  }
  
  return results;
}
```

### 4. **内存管理**
```javascript
// 及时清理Blob URLs
function cleanupAudioResources(audioList) {
  audioList.forEach(audio => {
    if (audio.audioUrl) {
      URL.revokeObjectURL(audio.audioUrl);
    }
  });
}

// 页面卸载时清理
window.addEventListener('beforeunload', () => {
  cleanupAudioResources(audioList);
});
```

### 5. **用户体验优化**

#### 加载状态管理
```javascript
// 显示详细的加载进度
function showProgress(current, total, message) {
  const percentage = Math.round((current / total) * 100);
  console.log(`📊 ${message}: ${current}/${total} (${percentage}%)`);
  
  // 更新UI进度条
  updateProgressBar(percentage);
}
```

#### 错误重试机制
```javascript
// 实现自动重试
async function fetchWithRetry(fetchFunction, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchFunction();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      console.warn(`重试 ${i + 1}/${maxRetries}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }
}
```

---

## 🔧 最佳实践

### 1. **安全性**
- 始终使用HTTPS传输音频数据
- 不要将音频令牌存储在本地存储中
- 定期检查令牌有效期并及时更新

### 2. **性能**
- 实现音频预加载机制
- 使用Web Workers处理大量音频数据
- 启用音频压缩传输

### 3. **用户体验**
- 提供音频加载进度提示
- 支持音频播放控制（播放/暂停/进度条）
- 实现音频下载功能

### 4. **错误处理**
- 提供友好的错误提示信息
- 实现自动重试机制
- 记录详细的错误日志用于调试

---

## 🚀 扩展功能

### 1. **批量下载**
```javascript
async function batchDownloadAudios(audioList, zipFilename = 'evaluation_audios.zip') {
  const JSZip = require('jszip');
  const zip = new JSZip();
  
  for (const audio of audioList) {
    const filename = `${audio.questionId}_${audio.evaluationId}.wav`;
    zip.file(filename, audio.audioBlob);
  }
  
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  
  const link = document.createElement('a');
  link.href = URL.createObjectURL(zipBlob);
  link.download = zipFilename;
  link.click();
}
```

### 2. **音频可视化**
```javascript
// 使用Web Audio API实现音频波形显示
function createAudioVisualizer(audioElement, canvasElement) {
  const audioContext = new AudioContext();
  const analyser = audioContext.createAnalyser();
  const source = audioContext.createMediaElementSource(audioElement);
  
  source.connect(analyser);
  analyser.connect(audioContext.destination);
  
  analyser.fftSize = 256;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  function draw() {
    requestAnimationFrame(draw);
    
    analyser.getByteFrequencyData(dataArray);
    
    const canvas = canvasElement;
    const canvasCtx = canvas.getContext('2d');
    
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    
    const barWidth = (canvas.width / bufferLength) * 2.5;
    let barHeight;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      barHeight = dataArray[i] / 2;
      
      canvasCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
      canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
      
      x += barWidth + 1;
    }
  }
  
  draw();
}
```

### 3. **音频分析**
```javascript
// 分析音频特征（时长、音量等）
async function analyzeAudio(audioBlob) {
  return new Promise((resolve) => {
    const audio = new Audio();
    const url = URL.createObjectURL(audioBlob);
    
    audio.addEventListener('loadedmetadata', () => {
      const analysis = {
        duration: audio.duration,
        fileSize: audioBlob.size,
        format: audioBlob.type,
        bitRate: Math.round((audioBlob.size * 8) / audio.duration / 1000), // kbps
        sampleRate: null // 需要Web Audio API获取
      };
      
      URL.revokeObjectURL(url);
      resolve(analysis);
    });
    
    audio.src = url;
  });
}
```

---

## 📞 技术支持

如有任何问题或需要技术支持，请参考以下资源：

- **API文档**: [完整API参考文档](./API_DOCUMENTATION.md)
- **音频接口指南**: [音频API前端使用指南](./AUDIO_API_FRONTEND_GUIDE.md)
- **错误排查**: [常见问题解决方案](./TROUBLESHOOTING.md)

---

## 📝 更新日志

### v1.0.0 (2025-10-21)
- ✅ 完成评估详情音频获取完整流程文档
- ✅ 提供JavaScript/TypeScript完整实现
- ✅ 添加React和Vue.js组件示例
- ✅ 包含错误处理和性能优化建议
- ✅ 提供扩展功能实现方案
